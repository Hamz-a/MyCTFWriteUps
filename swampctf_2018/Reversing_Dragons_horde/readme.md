# Reversing Dragon's horde

## Challenge description:

You are a member of the dragon slayer's guild within your town.
Word comes to the guild of a dragon seen in a nearby mountain range.
You and your party decide to go out and slay the beast.
There is surely great wealth and glory to be obtained.
But be careful, dragons can be tricky creatures to deal with.

[adventure](files/adventure)

--- 

## Solution:

We were given a 32-bit ELF file:

```
$ file adventure
adventure: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=ed180ea5005352722a4eacb827629c058c89e56e, not stripped
```

I tried to run it but got:
```
$ ./adventure 
./adventure: /usr/lib/i386-linux-gnu/libstdc++.so.6: version `GLIBCXX_3.4.21' not found (required by ./adventure)
```

Spent a few minutes trying to fix this error and then thought "Since it's a 32-bit binary, let's drop it in [retdec.com](https://retdec.com/decompilation/)".

Retdec is an online decompilation service, it currently only supports 32-bit binaries. The decompilation is not perfect (a pretty hard problem) but it's enough for us. Here's an excerpt of the C decompiled file:

```
//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//
// ------------------------ Functions -------------------------

// Address range: 0x8048990 - 0x80489bf
void __ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6___GLIBCXX_3_4(void) {
    // 0x8048990
    return;
}

// Address range: 0x8048b0b - 0x8048b2c
// Demangled:     foo1()
int32_t _Z4foo1v(void) {
    // 0x8048b0b
    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEpLEc((int32_t)&g5, 102);
    return 102;
}

// Address range: 0x8048b2d - 0x8048b4e
// Demangled:     foo2()
int32_t _Z4foo2v(void) {
    // 0x8048b2d
    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEpLEc((int32_t)&g5, 108);
    return 108;
}

// Address range: 0x8048b4f - 0x8048b70
// Demangled:     foo3()
int32_t _Z4foo3v(void) {
    // 0x8048b4f
    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEpLEc((int32_t)&g5, 97);
    return 97;
}

// Address range: 0x8048b71 - 0x8048b92
// Demangled:     foo4()
int32_t _Z4foo4v(void) {
    // 0x8048b71
    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEpLEc((int32_t)&g5, 103);
    return 103;
}

// Address range: 0x8048b93 - 0x8048bb4
// Demangled:     foo5()
int32_t _Z4foo5v(void) {
    // 0x8048b93
    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEpLEc((int32_t)&g5, 123);
    return 123;
}

// Address range: 0x8048bb5 - 0x8048bd6
// Demangled:     foo6()
int32_t _Z4foo6v(void) {
    // 0x8048bb5
    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEpLEc((int32_t)&g5, 114);
    return 114;
}

// Address range: 0x8048bd7 - 0x8048bf8
// Demangled:     foo7()
int32_t _Z4foo7v(void) {
    // 0x8048bd7
    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEpLEc((int32_t)&g5, 51);
    return 51;
}

// Address range: 0x8048bf9 - 0x8048c1a
// Demangled:     foo8()
int32_t _Z4foo8v(void) {
    // 0x8048bf9
    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEpLEc((int32_t)&g5, 118);
    return 118;
}

// Address range: 0x8048c1b - 0x8048c3c
// Demangled:     foo9()
int32_t _Z4foo9v(void) {
    // 0x8048c1b
    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEpLEc((int32_t)&g5, 95);
    return 95;
}

// Address range: 0x8048c3d - 0x8048c5e
// Demangled:     foo10()
int32_t _Z5foo10v(void) {
    // 0x8048c3d
    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEpLEc((int32_t)&g5, 49);
    return 49;
}

// Address range: 0x8048c5f - 0x8048c80
// Demangled:     foo11()
int32_t _Z5foo11v(void) {
    // 0x8048c5f
    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEpLEc((int32_t)&g5, 116);
    return 116;
}

// Address range: 0x8048c81 - 0x8048ca2
// Demangled:     foo12()
int32_t _Z5foo12v(void) {
    // 0x8048c81
    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEpLEc((int32_t)&g5, 95);
    return 95;
}

// Address range: 0x8048ca3 - 0x8048cc4
// Demangled:     foo13()
int32_t _Z5foo13v(void) {
    // 0x8048ca3
    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEpLEc((int32_t)&g5, 117);
    return 117;
}

// Address range: 0x8048cc5 - 0x8048ce6
// Demangled:     foo14()
int32_t _Z5foo14v(void) {
    // 0x8048cc5
    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEpLEc((int32_t)&g5, 112);
    return 112;
}

// Address range: 0x8048ce7 - 0x8048d08
// Demangled:     foo15()
int32_t _Z5foo15v(void) {
    // 0x8048ce7
    _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEpLEc((int32_t)&g5, 125);
    return 125;
}

// Address range: 0x8048d09 - 0x8049422
int main(int argc, char ** argv) {
 // redacted
}
```

We have `foo[1-15]` functions and a main function. The foo functions return certain values. If we convert these integers to their respective ASCII values, we get the flag.

The above approach is a bit lame, so let's solve this in another way with [radare2](https://github.com/radare/radare2). r2 is a reverse engineering framework, it can be automated with [r2pipe](https://github.com/radare/radare2-r2pipe). So I wrote the following script in order to extract the flag from the functions:

```
import r2pipe

print("[+] Opening binary...")
r2 = r2pipe.open("./adventure")

print("[+] Analysing the binary...")
r2.cmd("aaa")

print("[+] Looping through foo[1-15] functions...")
flag = ''
for i in range(1, 16):
    print("[+] Disassembling foo%s function..." % i)
    instructions = r2.cmdj("pdj 4 @sym.foo" + str(i))  # Get first 4 assembled instructions
    opcode = instructions[-1]['opcode'].strip()  # Get last instruction
    character = chr(int(opcode[-4:], 16))  # Convert hex character from opcode to ASCII
    print("Opcode: " + opcode + ", chr: " + character)
    flag += character

print("flag: " + flag)
```

Here's the script's output:

![r2pipe output](files/r2_rocks.png?raw=true)
