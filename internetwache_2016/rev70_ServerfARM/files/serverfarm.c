//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2016 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct struct_1 {
    char e0;
    char e1;
};

// ------------------- Function Prototypes --------------------

int32_t handle_task(int32_t a1, struct struct_1 * a2);

// ------------------------ Functions -------------------------

// Address range: 0x106a8 - 0x1073b
int main(int argc, char ** argv) {
    char * mem = malloc(101); // 0x106c0
    // branch -> 0x106d8
    for (int32_t i = 0; i < argc - 1; i++) {
        // 0x106d8
        printf("Enter Solution for task %d:", i);
        scanf("%s", mem);
        handle_task(i, (struct struct_1 *)mem);
        // continue -> 0x106d8
    }
    // 0x1071c
    free(mem);
    return 0;
}

// Address range: 0x1073c - 0x10963
int32_t handle_task(int32_t a1, struct struct_1 * a2) {
    int32_t v1 = 0; // bp-4
    int32_t v2 = &v1; // 0x10740_0
    int32_t puts_rc = a1; // 0x10928_12
    switch (a1) {
        case 0: {
            // 0x10778
            *(int32_t *)(v2 - 20) = 0;
            uint32_t len = strlen((char *)*(int32_t *)(v2 - 28)); // 0x107b48
            uint32_t v3 = *(int32_t *)(v2 - 20); // 0x107bc12
            int32_t v4 = v2;
            if (len > v3) {
                int32_t v5 = v2; // 0x10798
                while (true) {
                    char v6 = *(char *)(*(int32_t *)(v5 - 28) + v3); // 0x10790
                    int32_t * v7 = (int32_t *)(v5 - 16); // 0x10798_0
                    *v7 = *v7 + (int32_t)v6;
                    int32_t * v8 = (int32_t *)(v2 - 20); // 0x107a4_0
                    *v8 = *v8 + 1;
                    uint32_t len2 = strlen((char *)*(int32_t *)(v2 - 28)); // 0x107b4
                    uint32_t v9 = *(int32_t *)(v2 - 20); // 0x107bc
                    if (len2 <= v9) {
                        v4 = v2;
                        // break (via goto) -> 0x107c8
                        goto lab_0x107c8;
                    }
                    v3 = v9;
                    v5 = v2;
                    // continue -> 0x10784
                }
            }
          lab_0x107c8:;
            int32_t str = *(int32_t *)(v4 - 28); // 0x107cc
            int32_t v10 = *(int32_t *)(v4 - 16) / strlen((char *)str); // 0x107e0
            *(int32_t *)(v2 - 16) = v10;
            printf("%s", "Here's your 1. block:");
            if (*(int32_t *)(v2 - 16) < 36) {
                // 0x10810
                printf("%s", "IW{");
                putchar(83);
                printf("%c%c\n", 46, 69);
                // branch -> 0x10918
                // 0x10918
                puts_rc = v10;
                // branch -> 0x10924
            } else {
                // 0x10804
                puts_rc = puts("I{WAQ3");
                // branch -> 0x10924
            }
            // 0x10924
            return puts_rc;
        }
        case 1: {
            // 0x10838
            printf("%s", "Here's your 2. block:");
            uint32_t v11 = (int32_t)a2->e0; // 0x10848
            uint32_t v12 = (int32_t)*(char *)((int32_t)a2 + 1); // 0x10858
            if (v11 % v12 == 65) {
                // 0x10874
                printf("%s", ".R.");
                putchar(86);
                printf("%c%c\n", 46, 69);
                // branch -> 0x10918
            } else {
                // 0x1089c
                puts("WI{QA3");
                // branch -> 0x10918
            }
            // 0x10918
            puts_rc = v11 / v12;
            // branch -> 0x10924
            break;
        }
        case 2: {
            // 0x108a8
            printf("%s", "Here's your 3. block:");
            if (strcmp(&a2->e0, "1337") == 0) {
                // 0x108cc
                puts(".R>=F:");
                // branch -> 0x10918
            } else {
                // 0x108d8
                printf("%c%s%c\n", 46, "Q.D.Q", 33);
                // branch -> 0x10918
            }
            // 0x10918
            puts_rc = 0;
            // branch -> 0x10924
            break;
        }
        case 3: {
            // 0x108f0
            int32_t chars_printed; // 0x109201
            if (a2->e0 != 0) {
                // 0x10900
                chars_printed = printf("%c%s%c\n", 65, ":R:M", 125);
                // branch -> 0x10914
            } else {
                chars_printed = 3;
            }
            // 0x10914
            // branch -> 0x10918
            // 0x10918
            puts_rc = chars_printed;
            // branch -> 0x10924
            break;
        }
    }
    // 0x10924
    return puts_rc;
}

// --------------- Dynamically Linked Functions ---------------

// void free(void *);
// void * malloc(size_t);
// int printf(const char *restrict, ...);
// int putchar(int);
// int puts(const char *);
// int scanf(const char *restrict, ...);
// int strcmp(const char *, const char *);
// size_t strlen(const char *);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (5.3.0)
// Detected functions: 2
// Decompiler release: v2.1.2 (2016-01-27)
// Decompilation date: 2016-02-22 10:09:14
